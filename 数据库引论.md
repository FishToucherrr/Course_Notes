#  第一章 数据库概论

## 数据库由来与发展

### 人工管理阶段

### 文件系统阶段

### 数据库阶段

DB：DataBase 数据库

DBMS：DataBase Management System 数据库管理系统

DBS：DataBase System   数据库系统   

### 高级数据库

## 数据描述

### 概念设计中的数据描述

实体 实体集 属性 实体标识符

### 逻辑设计中的数据描述

字段 记录 文件 关键码

### 物理设计中的数据描述

### 数据联系的描述

N元联系

一对一联系，一对多联系，多对多联系

## 数据抽象的级别

### 数据抽象的过程

### 概念模型

实体联系模型-ER模型

### 逻辑模型

1. 层次模型
2. 网状模型
3. 关系模型
4. 对象模型

### 外部模型

针对具体用户需要的数据设计

### 内部模型（物理模型）

数据库最低层的抽象

描述数据存储方式、存取设备、存取方法

### 三层模式和两级映像

1. 外模式、逻辑模式、内模式
2. 两级映像

## 数据库管理系统

## 数据库系统

### 组成

数据库 硬件 软件 数据库管理员

### 分类

集中式

客户机/服务器式

并行式

分布式

# 第二章 关系模型和关系运算理论

## 基本概念

### 基本术语

字段=属性 字段值=属性值 记录类型—关系模式

记录—元组  元组的集合—关系/实例

#### 关键码

1. 超键：唯一标识元组
2. 候选键：不含有多余属性的超键
3. 主键：被选作元组标识的候选键
4. 外键：其他模式的主键

### 关系的定义和性质

关系是一个属性数目相同的元组的集合

1. 每个属性值不可分解
2. 不允许重复
3. 元组无序
4. 属性无序

### 关系模型的3类完整性规则

#### 实体完整性规则

主键属性不能为空值

#### 参照完整性规则

外键值要么是主键值，要么是空值（视情况决定允许为空）

#### 用户定义的完整性规则

### 关系模型的3层体系结构

1. 关系模式（记录类型）
2. 子模式（用户所用到那部分数据的描述）
3. 存储模式（关系存储时作为文件看待）

## 关系代数

### 关系代数的5个基本操作

并 差 笛卡尔积 投影 选择 

### 关系代数的4个组合操作

交 连接 自然连接 除法

除法：R÷S= R中包含S中所有元组的  元组的投影

### 关系代数的7个扩充操作

改名 ρ

广义投影（表达式）

赋值 ←

外连接：自然连接保存本该丢弃的元组	左外连接	右外连接

外部并：R S关系模式不同时 新关系的属性由RS所有属性组成，公共取一次

半连接：R S自然连接在R上的投影

聚集操作：max min avg sum count ...

## 关系演算

### 关系元组演算

3种原子公式-公式

关系代数表达式→元组表达式

### 域关系演算

元组表达式→域表达式

### 关系运算的安全约束和等价性

1. 关系代数中没有“补”操作，关系演算则不然，可能出现无限关系|无穷验证
2. 关系运算的等价性|前三者完全等价

## 关系代数表达式的优化

### 关系代数表达式的优化问题（笛卡尔积/连接）

### 关系代数表达式的等价变换规则

### 关系代数表达式的启发式优化算法

1. 尽可能早地执行选择操作
2. 尽可能早地执行投影操作
3. 避免直接做笛卡尔积

## 关系逻辑

### 成分

谓词 原子 规则

W（a,b）←S（a,b,c,'M'）^ c>=20

### 规则的安全性

头部关系应为有限的

安全条件：变量必须出现在某个非求反的关系子目标中

### 从关系代数到关系逻辑的转换

并集需要用若干条规则完成

### 递归过程

直接或间接地调用自身

# 第三章 关系数据库语言SQL

## SQL的数据定义

### 模式创建|撤销

create schema<模式名> authorization 用户名；

drop schema<模式名> cascade / restrict

cascade 级联式

restrict 约束式

### 基本表的创建、修改和撤销

```mysql
create table c
(
    C# char(4),
    CNAME char(10)not null,
    T# char(4),
    primary key(c#),
    foreign key(T#) references T(T#)
);
```

#### 增加新的列

alter table c add address varchar(30);

新增加的列不能定义为NOT NULL

#### 删除原有的列

alter table c drop  cname cascade;

#### 修改原有列的类型/长度

alter table c modify cname char(6);

### 索引的创建和撤销

create unique index 索引名 on c（C #，DESC）//降序

撤销：drop index 索引名

## SQL数据查询

### select语句基本结构

```mysql
select a,b
from c,d
where F;
```

谓词：exists、some、all、unique

查询结果：union、intersect(交)、except(差)

```mysql
select a
from b as c
where d
group by e
	heving 
order by x , y, z DESC;
```

### 数据查询中的限制和规定

1. distinct all
2. select a as b
3. 两个子查询结果结构完全一致时，可以进行并 交 差 操作

### 条件表达式中的比较操作

1. a (not) between ... and ...
2. 字符串 （not）like 模式
3. a is (not) null
4. a θ all|some
5. (not) exists
6. (not) unique 判断是否有重复元祖

字符串匹配：

% = 零个或多个         _ = 单个字符

转义：a like b escape ‘\’    （例）

### 嵌套查询的改进写法

#### 导出表

```mysql
from (select ...) as result(a)
```

#### with子句和临时视图

```mysql
with result(a) as
	select ...
select ...
```

### 基本表的连接操作

inner join 内连接

left outer join 左外连接

right outer join 右外连接

full outer join 完全外连接

### SQL3 递归查询

如 递归 规则

pre(x,y) ← course(x,u,y)

pre(x,y) ← course(x,u,z)^pre(z,y)

COURSE(C#,CNAME,PC#)

```mysql
with recursive pre(c#,pc#) as
     ((select c#, pc# from course)
       union
       (select course.c#,pre.pc#
       from course,pre
       where course.pc#=pre.c#)
     )
select * from pre;
```

## SQL 数据更新

#### 插入

insert into S(a,b,c,d)

​	values(e,f,g,h);

insert into S(a,b,c,d)

​	(select ...);

#### 删除

delete from S

where ...

#### 修改

update S

set x=y   ROW=(x,y,z)

where ...

## 视图

### 创建和撤销

#### 创建

create S（a,b,c）

​	as select ... ;

#### 撤销

drop view S；

#### 更新

只对行列子集视图更新（只用选择/投影导出的视图）

更新语句与前面一致

## 嵌入式SQL

### 区分语句

exec sql <sql语句> end_exec 结束标志可能为 ；

### 说明变量

引用变量前面要用 ":"作为前缀标识

exec sql begin declare section;

​	...;

exec  sql end declare section;

### 游标

#### 定义

exec declare <游标名> cursor for

​	select ...

end_exec

说明语句，select 语句不执行。

#### 打开

执行select语句，同时游标处于活动状态，此时指针指向查询结果的第一行之前

exec sql open 游标名 end_exec

#### 游标推进

推进一行，并取出当前的值

exec sql fetch from 游标名 into 变量表 end_exec

#### 游标关闭

exec sql close 游标名 end_exec

### 使用

#### 不涉及游标的SQL DML语句

加上前缀和结束标识就可嵌入到主语言程序中使用

select 语句要加一个INTO 语句

#### 涉及游标的SQL DML语句

1. 定义一个游标与某个select语句对应
2. open游标
3. fetch
4. close 关闭的游标可以被重新打开

#### 对游标指向元组的修改或删除

delete set  语句 where + current of 游标名

#### 卷游标-进退自如

exec sql declare 游标名 scroll cursor for

​	select ...;

end_exec

推进句法：fetch + next / prior / first / last / relative int / absolute int

### 动态sql语句  真不想看了

## 存储过程与SQL/PSM

### 数据库存储过程与函数

程序以数据库对象的形式存储在数据库中-称为存储过程

### SQL/PSM

#### 顺序执行

#### 条件分支

#### 循环语句

# 关系数据库的规范化设计

## 关系模式的设计问题

### 关系模式的外延和内涵

外延：关系、表、当前值

内涵：与实践独立，是对数据的定义以及数据完整性约束的定义

（1）静态约束：数据间的联系（数据依赖）

（2）动态约束：定义各种操作对关系值的影响

一般把内涵称为关系模式，所以关系模式应该包含这些内容

### 关系模式的冗余和异常问题

“分解”是解决冗余的主要方法，也是规范化的一条原则

### 关系模式的非形式化设计准则

1. 尽可能只包含直接联系的属性，不包含间接联系的属性
2. 尽可能使相应关系不出现插入、删除和修改等操作异常现象
3. 尽可能避免经常为空值的属性
4. 尽可能使等值连接发生在主键和外键上

## 函数依赖

### 函数依赖的定义

X Y是U的子集  FD X→Y 在关系模式R（U）上成立

一一对应 X←→Y

### FD的逻辑蕴涵

### FD的推理规则

1. 自反性
2. 增广性：XZ→YZ
3. 传递性
4. 合并性
5. 分解性
6. 伪传递性
7. 复合性 XW→Y
8. 通用一致性 没啥用 

平凡的FD / 非平凡的FD

### FD和关键码的联系

### 属性集的闭包

X+ = ｛A | F - X→A｝

### FD推理规则的完备性

正确性: 从FD集F使用推理规则集推出的FD必在F+中；

完备性：F+中的FD都能从F集使用推理规则导出

### FD集的最小依赖集

等价的函数依赖集

#### 定义

1. 每个FD的右边都是单属性
2. 没有冗余的FD；
3. 每个FD左边没有冗余的属性

#### 算法

1. 分解成每个FD右边都为单属性
2. 在每个FD中消除左边的冗余属性
3. 在G中消除冗余的属性

## 关系模式的分解特性

### 模式分解问题

### 无损分解

无损分解/损失分解

寄生元组

泛关系假设

在无泛关系假设时，对两个关系进行自然连接中被丢失的元组称为悬挂元组。

悬挂元组是造成两个关系不存在泛关系的原因。

### 模式分解的优缺点

#### 优点：

1. 消除冗余和操作异常
2. 课存储悬挂元组

#### 缺点：

1. 分解后连接将付出时间代价
2. 有泛关系假设时，自然连接可能产生寄生元组；无泛关系假设时由于可能存在悬挂元组，可能不存在泛关系。

### 无损分解的测试

p127

Chase 过程

### 保持函数依赖的分解

### 模式分解和模式等价问题

数据等价

语义等价

## 关系模式的范式

### 第一范式

每个关系r的属性值都不可分

### 第二范式

是1NF 且每个非主属性完全函数依赖于候选键

### 第三范式

是1NF且每个非主属性不传递依赖于R的候选键 

或者：

对每个非平凡的FD X→Y，都有X是R的超键，或Y的每个属性都是主属性。

### BCNF

是1NF且每个属性都不传递依赖于R的候选键

或者：对于每个非平凡FD X→Y，都有X是R的超键

# 数据库设计与ER模型

## 数据库设计的全过程

### 数据库系统生存期

### 规划阶段

### 需求分析阶段

### 概念设计阶段

### 逻辑设计阶段

### 物理设计阶段

### 数据库实现

### 数据库的运行与维护

## ER模型

### ER模型的基本元素

#### 实体

#### 联系

#### 属性

### 属性的分类

#### 简单属性和复合属性

#### 单值属性和多值属性

#### 存储属性和派生属性

#### 允许为空值的属性

### 联系的设计

#### 联系的元数

#### 联系类型的约束

基数 / 参与约束

### ER模型的操作

#### 分裂 合并 增删

### 采用ER模型的数据库概念设计 

## ER模型到关系模型的转换

### 不会有人不会吧

## ER模型实例分析

### 没必要

## 增强的ER模型

### 弱实体和强实体

### 子类实体和超类实体

#### 概化 特化

#### 不相交约束：不相交/重叠     d / o

#### 完备性约束： 整体特化/部分特化 双线条/单线条